# -*- coding: utf-8 -*-
"""Copy of Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fgHrJD8t3omIqDvwFICCKyv46yI3Wa6I
"""

# Importing necessary libraries
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.datasets import mnist
import matplotlib.pyplot as plt

# Step 1: Load the MNIST dataset
# The dataset is automatically available through TensorFlow/Keras
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

# Step 2: Preprocess the data
# Normalize the pixel values to be between 0 and 1 (currently they are between 0 and 255)
train_images = train_images / 255.0
test_images = test_images / 255.0

# Step 3: Build the CNN model
model = models.Sequential()

# Add the convolutional layers
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))

# Flatten the output and add fully connected layers
model.add(layers.Flatten())
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(10, activation='softmax'))  # 10 output units for 10 digit classes (0-9)

# Step 4: Compile the model
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Step 5: Train the model
# Reshape data for compatibility with the CNN (adding a 1-channel dimension for grayscale)
train_images = train_images.reshape((train_images.shape[0], 28, 28, 1))
test_images = test_images.reshape((test_images.shape[0], 28, 28, 1))

# Fit the model to the training data
history = model.fit(train_images, train_labels, epochs=5, validation_data=(test_images, test_labels))

# Step 6: Evaluate the model on the test set
test_loss, test_acc = model.evaluate(test_images, test_labels)
print(f"Test accuracy: {test_acc * 100:.2f}%")

# Step 7: Plot the training and validation accuracy
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

import tensorflow as tf
import matplotlib.pyplot as plt

# Step 1: Load the MNIST dataset
(train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data()

# Step 2: Preprocess the data (normalize the images by dividing by 255)
train_images = train_images / 255.0
test_images = test_images / 255.0

# Step 3: Visualize the first 16 images from the training dataset
plt.figure(figsize=(10, 10))

for i in range(16):  # Display the first 16 images
    plt.subplot(4, 4, i + 1)
    plt.imshow(train_images[i], cmap='gray')  # No need to reshape, since MNIST is 28x28
    plt.title(f"Label: {train_labels[i]}")  # Display the label
    plt.axis('off')

plt.show()

import tensorflow as tf
import requests
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Step 1: Download the image from a URL
url = 'https://images.squarespace-cdn.com/content/v1/54822a56e4b0b30bd821480c/45ed8ecf-0bb2-4e34-8fcf-624db47c43c8/Golden+Retrievers+dans+pet+care.jpeg'  # Replace with the actual URL of the dog image
response = requests.get(url, stream=True)
img = Image.open(response.raw)

# Step 2: Resize the image to fit the model's input size (for MobileNetV2, it's 224x224)
img = img.resize((224, 224))

# Step 3: Convert the image to a numpy array and preprocess it
img_array = np.array(img)
img_array = img_array / 255.0  # Normalize pixel values
img_array = np.expand_dims(img_array, axis=0)  # Add a batch dimension

# Step 4: Load a pre-trained model (MobileNetV2) with ImageNet weights
model = tf.keras.applications.MobileNetV2(weights='imagenet')

# Step 5: Use the model to make predictions
predictions = model.predict(img_array)

# Decode the predictions
decoded_predictions = tf.keras.applications.mobilenet_v2.decode_predictions(predictions, top=3)

# Step 6: Display the image and the predictions
plt.imshow(img)
plt.axis('off')
plt.show()

# Print the top 3 predictions
for i, (imagenet_id, label, score) in enumerate(decoded_predictions[0]):
    print(f"{i+1}: {label} ({score * 100:.2f}%)")

